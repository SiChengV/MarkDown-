[TOC]

## 工具使用

### Docker

```shell
docker pull xxx   # 拉取docker镜像
docker image ls   # 查看已有docker镜像
docker run -itd   {REPOSITORY:TAG}  /bin/bash   # -i 交互式操作 -t终端 -d 后台运行。 放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash
docker ps -a      # 查看容器的信息
docker cp /devcloud/FPINF_1.1.0 ceeb2a73028c:/home/   # 从宿主机拷贝文件到docker中，ceeb2a73028c为docker容器的ID

# 进入container并调出终端；exec模式exit不会停止容器，推荐
docker exec -it ceeb2a73028c /bin/bash

# 删除容器
docker rm -f {CONTAINERID}
```

### perf

Perf工作模式分为Counting Mode和Sampling Mode，Counting Mode将会精确统计一段时间内CPU相关硬件计数器数值的变化，为了统计用户感兴趣的事件，Perf Tool将设置性能控制相关的寄存器，这些寄存器的值将在监控周期结束后被读出，典型工具Perf Stat；Sampling Mode将以定期采样方式获取性能数据，PMU计数器将为某些特定事件配置溢出周期，当计数器溢出时，相关数据如 IP、通用寄存器、EFLAG 将会被捕捉到，典型工具Perf Record。

<font size=5>perf stat</font>

可以整体看看程序运行是各种统计时间的大概情况。**Perf stat通过概括精简的方式提供被调试程序运行的整体情况和汇总数据**。

* 使用方法

  ```shell
   perf stat ./excutbleFile  #停止后即可显示统计结果。可通过-r参数指定重复执行次数
   perf stat -p $pid -d     #进程级别统计
   perf stat -a -d sleep 5  #系统整体统计
   perf stat -p $pid -e 'syscalls:sys_enter' sleep 10  #分析进程调用系统调用的情形
   perf stat -a sleep 5 #收集整个系统的性能计数，持续5秒
   perf stat -C 0  #统计CPU 0的信息
  ```

  显示结果各字段意义：

  - task-clock-msecs：CPU利用率，此值越高说明程序的多数时间花费在CPU计算上而非IO；
  - context-switches：进程切换次数，记录程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的；（应该是上下文切换吧？）
  - cache-misses：程序运行过程中总体的cache利用情况，如果该值过高，说明程序的cache利用不好；
  - CPU-migrations：表示进程t1运行过程中发生了多少次CPU迁移，即被调度器从一个CPU转移到另外一个CPU上运行；
  - cycles：处理器时钟，一条指令可能需要多个cycles；
  - instructions:机器指令数目；
  - IPC：instructions/cycles的比值，该值越大越好，说明程序充分利用了处理器的特性；
  - cache-references：cache命中的次数；
  - cache-misses：cache失效的次数；

  通过-e选项，可以改变perf stat的缺省事件(perf list查看)，perf stat -h查看帮助信息。

<font size=5>**perf top**</font>

**用于实时统计当前系统的性能信息。**

可通过-e参数列出其他时间的TopN进程/函数，比如-e cache-miss，用于查看谁造成的cache miss最多（-e 可用参数可使用perf list查看）

* 使用方法

  ```shell
  perf top  #查看所有进程
  perf top -p $pid  #进程级别   -g 可列出详细信息
  ...
  ```

在**perf top界面按h键可以唤起帮助菜单**

<font size=5>perf record/report</font>

使用perf top和perf stat之后，对系统性能已经有了一个大致的了解，下面就需要进一步分析更细粒度的信息。**perf record记录单个函数级别的统计信息，并使用perf report来显示统计结果**。

* 使用方法

  ```shell
  perf record -p $pid
  perf record -p $pid -g  #详细采用，配合perf report -g使用   不加-g貌似只能以线程为粒度采集
  perf record -e cpu-clock ./$excutbleFile
  
  perf report $file   #查看统计信息
  perf report -g $file   #查看信息统计信息
  ```

<font size=5>perf script</font>

读取Perf record结果

## Git

* 下载安装git

* 配置个人身份

  `git config --global user.name "名字"`  配置用户级的个人身份

  `git config --global user.email 邮箱`  

  以上信息会在仓库中提交的修改信息中体现

* 基础操作

  `git init 工程名` 创建一个新的git工程

  `git clone url`  克隆远端工程到本地

  `git add 文件名`   将指定新文件添加到暂存区

  `git add .`   将全部新文件添加到暂存区

  ` git rm 文件名`  将文件移出暂存区并删除物理文件

  `git rm --cached xxx 或 git reset HEAD xxx` 将add进暂存区的文件移出暂存区

  `git mv 源 目的`   移动文件或重命名文件  （这种mv对git后续操作比较友好）

  `git diff `  查看版本、分支之间的差异

  `git status`  显示工作区目录和暂存区状态

  `git commit 文件名 -m "提交信息"`   将暂存区指定文件提交到本地版本库

  `git commit --amend "提交信息"`   修改上一次的commit信息，也可将新修改带入上一次commit

  `git reset HEAD@{1}` 可以撤销amend 只限amend了一次，如果amend了多次则需要用`git reflog`来确定撤销到哪里，然后再用`git reset --soft HEA@{x}` 来进行撤销

  (修改旧commit的内容)`git rebase -i HEAD`列出修改列表，将要修改的commit行的pick修改为reword，保存退出后修改commit的内容

  `git log`    查看提交历史

  `git log --name-status`   查看日志详细修改记录

  `git log -1`  查看最近一条日志 

  `git show [commitId] ` 查看指定commitId的详细修改内容 没有commitId则为最近一次

  `git push origin branch_name[:new_branch_name]`    将分支推送到远端服务器[取一个新名字]

  `git stash push/pop` 将修改藏入缓存/将缓存中的修改拿出

  

* 分支管理

  切换分支和新建分支会把修改一起带过去，已经commit的则不会带过去

  `git branch`    查看本地所有分支名称

  `git branch -r`    查看仓库服务器所有分支名称

  `git branch -vv` 查看分支详细信息

  `git branch 分支名`  新建分支（基于当前分支）

  `git checkout -b 分支名`    新建分支（会切换到新分支）

  `git branch -d 分支名`    删除分支 `-D`表示强制删除

  `git checkout 分支名`    切换分支 

  `git pull origin remote_branch`    从服务器拉取分支并合并

  `git fetch origin remote_branch`    从服务器拉取分支但不合并（merge）

  `git merge 分支名`    将指定分支合并到当前分支

  `git merge 源 目的`    将源分支合并到目的分支

* 撤销操作

  `git reset commit_id`     回退到指定commit_id

  `git reset --soft HEAD^` 撤回commit到上一个版本，保留代码变动，修改退回到暂存区

  `git reset --mixed HEAD^`  撤回commit到上一个版本，保留代码改动，并移出暂存区 等于 `git reset HEAD^`

  `git reset --hard HEAD^` 撤回commit到上一个版本，不保留代码改动

  `git reset --staged xxx` 将指定文件移出暂存区 可用通配符

  `git checkout .`     回退所有未提交到暂存区的文件（谨慎使用）

  `git checkout -- filename`     回退未提交到暂存区的指定文件

  `git checkout commit_id `    回退到commit_id这个节点

  `git clean -nxdf` 清除未跟踪的文件，-n表示模拟删除，确认没问题后可将n去掉进行实际删除

#### Git将本地的工程上传到新建的远程仓库

1. 在本地`git init`
2. 用git add将要上传的代码加入跟踪
3. git commit
4. 添加远程仓库的地址: `git remote add origin url`
5. git pull origin master 拉取远程仓库。如果报fatal: refusing to merge unrelated histories错就在后面添加参数：`--allow-unrelated-histories`，有冲突就处理冲突
6. git push origin master

#### git冲突处理

分两种情况：

1. merge时

   current changes代表自己分支上的修改

   imcoming changes代表从master分支拉取的代码内容

2. rebase时

   current changes代表从master分支拉取的代码

   incoming changes代表自己的分支上那些即将合入到master的代码修改

   rebase和merge的current changes和imcoming changes代表意义相反

   

## VsCode配置本地编译C++

需要先安装MinGw并记录安装地址

在.vscode下创建三个文件

1. launch.json

   ```json
   { // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
       "version": "0.2.0",
       "configurations": [
           {
               "name": "C++ Launch (GDB)", // 配置名称，将会在启动配置的下拉菜单中显示
               "type": "cppdbg", // 配置类型，这里只能为cppdbg
               "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加）
               "targetArchitecture": "x86", // 生成目标架构，一般为x86或x64，可以为x86, arm, arm64, mips, x64, amd64, x86_64
               "program": "${file}.exe", // 将要进行调试的程序的路径
               "miDebuggerPath": "D:\\App\\mingw64\\mingw64\\bin\\gdb.exe", // miDebugger的路径，注意这里要与MinGw的路径对应
               "args": [
                   "blackkitty",
                   "1221",
                   "# #"
               ], // 程序调试时传递给程序的命令行参数，一般设为空即可
               "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false
               "cwd": "${workspaceRoot}", // 调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录
               "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台
               "preLaunchTask": "g++" // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc
           }
       ]
   }
   ```

2. tasks.json

   ```json
   {
       "version": "0.1.0",
       "command": "g++",
       "args": ["-g", "${file}", "-std=c++17", "-o", "${file}.exe"], // 编译命令参数
       "problemMatcher": {
           "owner": "cpp",
           "fileLocation": [
               "relative",
               "${workspaceRoot}"
           ],
           "pattern": {
               "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",
               "file": 1,
               "line": 2,
               "column": 3,
               "severity": 4,
               "message": 5
           }
       }
   }
   ```

3. c_cpp_properties.json

   ```json
   {
       "configurations": [
           {
               "name": "Win32",
               "includePath": [
                   "${workspaceFolder}/**"
               ],
               "defines": [
                   "_DEBUG",
                   "UNICODE",
                   "_UNICODE"
               ],
               "compilerPath": "D:\\Program Files\\mingw64\\bin\\gcc.exe", // 此处路径要对
               "cStandard": "c11",
               "cppStandard": "c++17"
           }
       ],
       "version": 4
   }
   ```


## C知识

#### 计算程序运行时间

```c
#include <time.h>

printf("CLOCKS_PER_SEC = %ld\n", CLOCKS_PER_SEC);  // 计算机每秒cpu运行时钟周期数 计算机不同可能不同
clock_t start, end;
start = clock();
// 被测代码
end = clock();
printf("%ld", end - begin)
```

#### 打印错误码

```c
#include <errno.h>
#include <string.h>

printf("%s", strerror(errno));
```

#### 编译

**gcc编译**

* -L 指定编译时链接的动态库路径


### 编译/调试相关

#### valgrind

* "definitely lost"：确认丢失。程序中存在内存泄露，应尽快修复。当程序结束时如果一块动态分配的内存没有被释放且通过程序内的指针变量均无法访问这块内存则会报这个错误。

* "indirectly lost"：间接丢失。当使用了含有指针成员的类或结构时可能会报这个错误。这类错误无需直接修复，他们总是与"definitely lost"一起出现，只要修复"definitely lost"即可。例子可参考我的例程。

* "possibly lost"：可能丢失。大多数情况下应视为与"definitely lost"一样需要尽快修复，除非你的程序让一个指针指向一块动态分配的内存（但不是这块内存起始地址），然后通过运算得到这块内存起始地址，再释放它。例子可参考我的例程。当程序结束时如果一块动态分配的内存没有被释放且通过程序内的指针变量均无法访问这块内存的起始地址，但可以访问其中的某一部分数据，则会报这个错误。

* "still reachable"：可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源，因此笔者建议修复它。如果程序是崩溃（如访问非法的地址而崩溃）而非正常结束的，则应当暂时忽略它，先修复导致程序崩溃的错误，然后重新检测。



**valgrind --tool=massif**工具可用来分析内存泄漏情况

参考资料：

https://www.cnblogs.com/gmpy/p/14778243.html

#### CMake

```cmake
# 本CMakeLists.txt的project名称
# 会自动创建两个变量，PROJECT_SOURCE_DIR 和 PROJECT_NAME
# ${PROJECT_SOURCE_DIR}：本CMakeLists.txt所在的文件夹路径
# ${PROJECT_NAME}：本CMakeLists.txt的project名称
project(xxx)

# 给文件名/路径名或其他字符串起别名，用${变量}获取变量内容
set(变量 文件名/路径/...)

# 添加编译宏,代码中可以读到这些宏 可以使用命令关闭或开启：cmake -Dxxxxx=on/off
add_definitions(-Dxxx)

# 打印消息
message(消息)

# 添加一个子文件夹的CMakeLists.txt并构建
add_subdirectory(子文件夹名称)

# 将.cpp/.c/.cc文件生成.a静/动态库
# 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可
add_library(库文件名称 STATIC 文件)
add_library(库文件名称 SHARED 文件)

# 将.cpp/.c/.cc文件生成可执行文件,即编译可执行文件
add_executable(可执行文件名称 文件)

# 将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径。非递归添加，仅那一级目录
include_directories(路径)

# 即可将指定目录设为头文件搜索路径，等价于系统路径，甚至可用<>引用头文件。更常用的是在库中将目录设为.  这样此库被其他cmakelists target_link_libraries时会继承库的搜索路径。public改为private则不会将搜索路径传播出去
target_include_directories(a.out PUBLIC 目录)

 # 指定链接库文件路径
target_link_directories(a.out PUBLIC 目录)

# 规定.so/.a库文件路径 相当于编译的时候加了-L xxx
link_directories(路径)

# 对add_library或add_executable生成的文件进行链接操作
# 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可
target_link_libraries(编译工程名 链接的库文件名称)

# 搜索当前路径下的所有源代码文件并将列表存储到 xxx变量中
aux_source_directory(. xxx)

# 打印信息 
# (无) = 重要消息；
# STATUS = 非重要消息；
# WARNING = CMake 警告, 会继续执行；
# AUTHOR_WARNING = CMake 警告 (dev), 会继续执行；
# SEND_ERROR = CMake 错误, 继续执行，但是会跳过生成的步骤；
# FATAL_ERROR = CMake 错误, 终止所有处理过程；
message(STATUS "xxxx")

# 引用系统中预安装的第三方库
find_package(fmt REQUIRED)
target_link_libraries(myexec PUBLIC fmt::fmt)
# 指定要用其中的哪几个库
find_package(TBB REQUIRED COMPONENTS tbb tbbmalloc REQUIRED)
target_link_libraries(myexec PUBLIC TBB::tbb TBB::tbbmalloc)

```

![image-20230509202701627](../../typora%25E7%25AC%2594%25E8%25AE%25B0/%25E4%25B8%25AA%25E4%25BA%25BA%25E7%25AC%2594%25E8%25AE%25B0/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20230509202701627.png)

`set(CMAKE_VERBOSE_MAKEFILE TRUE) ` 可以开启cmake的调测信息

**编译流程：**

```shell
mkdir build  # 为了将编译过程中生成的文件放到build路径下，不破坏源码的目录结构  
cd build
cmake ..  # 前三步可以简化成 cmake -B build
make
```

## 



## Python知识

python调用shell并读取结果保存为string：`tmp = os.popen('ls').read()`

### 环境python混乱

表现在运行python脚本时，提示未找到模组，但是用pip安装时又提示已安装，python程序在执行是会有一个搜索路径，可以通过以下代码打印出来：

```python
import sys
sys.path
```

然后检查pip install时回显的已安装包所在路径，将这个路径用`export PYTHONPATH=路径`命令加入到python的搜索路径后，即可找到已安装的包

参考：https://blog.csdn.net/cc1949/article/details/78285842

### Python编译出无依赖的可执行程序

1. `pip install pyinstaller`
2. `pyinstaller -F xxx.py`

即可生成无依赖的可执行程序

### print

`print(xxxx, file=已打开的文件)`  可以将print重定向到open的文件中

`print(f"{变量名} xxxxxxx") ` 可以直接在字符串中插入变量的值

### python re模块

```python
import re

findall(string[, pos[, endpos]])  # pos和endpos为可选的指定字符串搜索起始位置和结束位置
result = re.findall("[\W]+", text)  # 使用正则表达式匹配text内的字符串

#正则表达式中用()包含的已匹配部分可以用gourp(x)函数取出 x从1开始为第一个括号里的匹配内容
```

* compile函数

  ```python
  pattern = re.compile(r'\S*_t')  # 编译出一个正则表达式
  result = pattern.findall(text)  # 使用正则表达式匹配字符串 findall表示匹配所有符合表达式的字符串 返回一个列表
  ```

### python类

python类内调用自己的成员函数需要加 `self.`

### 常用函数

* split

  ```python
  result = text.split("\n", splitTime)   # 使用\n作为分割符分割字符串，splitTime表示分割次数
  ```


### 常用的包

* pyflakes：可以使用pyflakes检查单个python文件的语法错误，`pyflakes xxx.py`



### GDB指南

* 编译和gdb运行二进制文件环境不一致导致无法查看源文件 **set substitute-path**

  当带符号表的二进制文件编译出来放到另一个地方跑的时候，用list列出源文件的时候会提示找不到源文件，可以看到提示的路径还是旧的、编译的是文件路径，而在运行环境上想看源文件需把源文件拷到运行环境，并使用`set substitute-path from_path to_path`将gdb搜索的目录替换，比如 list显示的源码是  /home/aaa/1.cpp，那么设置了 `set substitute-path /home/aaa/  /home/bbb/`，之后，即使你的源文件1.cpp 放在 /home/bbb下面也是可以找到的了。因为gdb帮你做了字符串替换。

调试正在运行的程序：gdb {program} {pid}

**gdb命令**

* `p $_siginfo` 打印接收到的信号的详细信息，例如：si_code表示信号产生的方式，si_pid表示发送信号的进程  相关信息可以看siginfo.h源码



### SElinux指南

SELinux安全上下文Security Context，由三部分组成：user:role:type



标签由.te和.fc两个文件配置

* .te文件

  ```
  attribute: 是一组有共性的type的集合，编译时这些attribute会被展开为type
  使用方法：
  attribute file_type  # 单独定义一个attribute
  typeattribute shadow_t file_type;   # 使用typeattribute进行声明，讲shadow_t加入filt_type里
  type shadow_t, file_type # 在定义时就进行关联
  
  allow：SElinux规则以白名单方式实现，所有操作由allow规则定义，否则默认禁止
  allow 由四部分组成：allow source_t target_t:obj_class permissions; # source_t为主体类型，进程标签中的type。target_t为客体标签，被访问对象的标签中的type。obj_class为被访问对象的类型(客体类型)，如：文件、目录、socket、capability等等。permissions为允许的访问方式。
  
  require：类似前向声明，用于引入非自定义的security_type
  ```

## 杂项知识

### UML类图

https://blog.csdn.net/smilehappiness/article/details/105527488

### top和ps -elf的pri和ni值不同的原因

ps 中的 `priority` 共有如下几种，其中 priority 为原始值

![image-20220906165513235](C:/Users/z30035528/Desktop/typora%25E7%25AC%2594%25E8%25AE%25B0/MarkdownPicBed/image-20220906165513235.png)

top打印的值是原始值priority，为20

ps -elf中的-l默认取的是opri中的值，其值为priority的值加上60，因此与top不同

### 如何将自己的可执行程序注册到Linux系统内

1. 将二进制可执行文件移动到/usr/local/bin/目录下
2. 将依赖库文件放到/usr/lib/目录下

或者直接把二进制文件的路径加到path里：`export PATH=xxxxxx:$PATH  添加bin文件默认路径`

### 添加动态库搜索路径

`export LD_LIBRARY_PATH=/opt/usr/mnt/lib:$LD_LIBRARY_PATH`

export LD_LIBRARY_PATH=/opt/platform/mdc_platform/lib/:$LD_LIBRARY_PATH





### 防止头文件重复包含

\#pragma once

### 编译选项

使用c++17标准中的功能需在编译时添加编译参数：`-std=c++17`

编译时生成编译指令json，导入到vscode中可以用来精确跳转`set(CMAKE_EXPORT_COMPILE_COMMANDS ON)`
